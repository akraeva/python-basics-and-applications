# Stepick.org — Python: основы и применение
# 1. Базовые принципы языка Python


# === 1.1 Введение ===


def m_1_1():
    """
    Реализуйте программу, которая принимает последовательность
    чисел и выводит их сумму.
    Вашей программе на вход подается последовательность строк.
    Первая строка содержит число n (1 ≤ n ≤ 100).
    В следующих n строках содержится по одному целому числу.
    Выведите одно число – сумму данных n чисел.
    """
    print(sum(int(input()) for _ in range(int(input()))))


# === 1.2 Модель данных: объекты ===


def m_1_2():
    """
    Реализуйте программу, которая будет вычислять количество различных
    объектов в списке. Два объекта a и b считаются различными, если
    a is b равно False. Вашей программе доступна переменная с названием
    objects, которая ссылается на список, содержащий не более 100 объектов.
    Выведите количество различных объектов в этом списке.
    """
    print(len(set(id(obj) for obj in (objects))))


# === 1.3 Функции и стек вызовов ===


def m_1_3_1():
    """
    Напишите реализацию функции closest_mod_5, принимающую в качестве
    единственного аргумента целое число x и возвращающую самое
    маленькое целое число y, такое что:
    - y больше или равно x
    - y делится нацело на 5
    """

    def closest_mod_5(x):
        if x % 5 == 0:
            return x
        y = 5 * (x // 5 + 1)
        return y


def m_1_3_2():
    """
    Сочетанием из n элементов по k называется подмножество этих n элементов
    размера k. Два сочетания называются различными, если одно из сочетаний
    содержит элемент, который не содержит другое. Числом сочетаний из n по k
    называется количество различных сочетаний из n по k.
    Обозначим это число за C(n, k).
    Для вычисления C(n, k) в других случаях используется следующая
    рекуррентная формула: C(n, k) = C(n - 1, k) + C(n - 1, k - 1).
    Реализуйте программу, которая для заданных n и k вычисляет C(n, k).
    Вашей программе на вход подается строка, содержащая
    два целых числа n и k (1 ≤ n ≤ 10, 0 ≤ k ≤ 10).
    Ваша программа должна вывести единственное число: C(n, k).
    """

    def combination(n, k):
        if k == 0:
            return 1
        if k > n:
            return 0
        return combination(n - 1, k) + combination(n - 1, k - 1)

    arg_n, arg_k = map(int, input().split())
    print(combination(arg_n, arg_k))


# === 1.4 Пространства имён и области видимости ===


def m_1_4_1():
    """
    Реализуйте программу, которая будет эмулировать работу с пространствами
    имен. Необходимо реализовать поддержку создания пространств имен и
    добавление в них переменных. В данной задаче у каждого пространства имен
    есть уникальный текстовый идентификатор – его имя.
    Вашей программе на вход подаются следующие запросы:
    create <namespace> <parent> –  создать новое пространство имен с именем
            <namespace> внутри пространства <parent>
    add <namespace> <var> – добавить в пространство <namespace>
            переменную <var>
    get <namespace> <var> – получить имя пространства, из которого будет взята
            переменная <var> при запросе из пространства <namespace>, или None,
            если такого пространства не существует
    Формат входных данных
        В первой строке дано число n (1 ≤ n ≤ 100) – число запросов.
        В каждой из следующих n строк дано по одному запросу.
        Запросы выполняются в порядке, в котором они даны во входных данных.
        Имена пространства имен и имена переменных представляют из себя строки
        длины не более 10, состоящие из строчных латинских букв.
    Формат выходных данных
        Для каждого запроса get выведите в отдельной строке его результат.
    """
    spaces = {"global": "None"}
    vars = {"global": set()}

    for _ in range(int(input())):
        request, namespace, data = input().split()
        if request == "create":
            spaces[namespace] = data
            vars[namespace] = set()
        elif request == "add":
            vars[namespace].add(data)
        elif request == "get":
            while namespace != "None":
                if data in vars[namespace]:
                    print(namespace)
                    break
                namespace = spaces[namespace]
            else:
                print("None")


# === 1.5 Введение в классы ===


def m_1_5_1():
    """
    Реализуйте класс MoneyBox, для работы с виртуальной копилкой.
    Каждая копилка имеет ограниченную вместимость, которая выражается
    целым числом – количеством монет, которые можно положить в копилку.
    Класс должен поддерживать информацию о количестве монет в копилке,
    предоставлять возможность добавлять монеты в копилку и узнавать,
    можно ли добавить в копилку ещё какое-то количество монет,
    не превышая ее вместимость.

    Класс должен иметь следующий вид

    class MoneyBox:
        def __init__(self, capacity):
            # конструктор с аргументом – вместимость копилки

        def can_add(self, v):
            # True, если можно добавить v монет, False иначе

        def add(self, v):
            # положить v монет в копилку

    При создании копилки, число монет в ней равно 0.
    Примечание: Гарантируется, что метод add(self, v) будет вызываться
                только если can_add(self, v) – True.
    """

    class MoneyBox:
        def __init__(self, capacity):
            self.capacity = capacity

        def can_add(self, v):
            return self.capacity >= v

        def add(self, v):
            self.capacity -= v


def m_1_5_2():
    """
    Вам дается последовательность целых чисел и вам нужно ее обработать и
    вывести на экран сумму первой пятерки чисел из этой последовательности,
    затем сумму второй пятерки, и т. д.
    Но последовательность не дается вам сразу целиком. С течением времени
    к вам поступают её последовательные части. Например, сначала первые три
    элемента, потом следующие шесть, потом следующие два и т. д.
    Реализуйте класс Buffer, который будет накапливать в себе элементы
    последовательности и выводить сумму пятерок последовательных элементов
    по мере их накопления.
    Одним из требований к классу является то, что он не должен хранить в себе
    больше элементов, чем ему действительно необходимо, т. е. он не должен
    хранить элементы, которые уже вошли в пятерку, для которой была
    выведена сумма. Обратите внимание, что во время выполнения метода add
    выводить сумму пятерок может потребоваться несколько раз до тех пор,
    пока в буфере не останется менее пяти элементов.
    """

    class Buffer:
        def __init__(self):
            self.nums = []

        def add(self, *a):
            for num in a:
                self.nums.append(num)
                if len(self.nums) == 5:
                    print(sum(self.nums))
                    self.nums.clear()

        def get_current_part(self):
            return self.nums


# === 1.6 Наследование классов ===


def m_1_6_1():
    """
    Вам дано описание наследования классов в следующем формате.
    <имя класса 1> : <имя класса 2> <имя класса 3> ... <имя класса k>
    Это означает, что класс 1 отнаследован от класса 2, класса 3, и т. д.
    Класс A является предком класса B, если
    - A = B;
    - A - прямой предок B
    - существует такой класс C, что C - прямой предок B и A - предок C
    Вам необходимо отвечать на запросы, является ли один класс предком
    другого класса. Важное примечание: Создавать классы не требуется.
    Мы просим вас промоделировать этот процесс, и понять существует ли
    путь от одного класса до другого.
    Формат входных данных
    В первой строке входных данных содержится целое число n - число классов.
        В следующих n строках содержится описание наследования классов.
        В i-й строке указано от каких классов наследуется i-й класс.
        Обратите внимание, что класс может ни от кого не наследоваться.
        Гарантируется, что класс не наследуется сам от себя (прямо или косвенно),
        что класс не наследуется явно от одного класса более одного раза.
    В следующей строке содержится число q - количество запросов.
        В следующих q строках содержится описание запросов в
        формате <имя класса 1> <имя класса 2>.
        Имя класса – строка, состоящая из символов латинского алфавита,
        длины не более 50.
    Формат выходных данных
        Для каждого запроса выведите в отдельной строке слово "Yes",
        если класс 1 является предком класса 2, и "No", если не является.
    """

    def is_anc(des, anc):
        if des == anc:
            return True
        if anc in classes[des]:
            return True
        for parent in classes[des]:
            if is_anc(parent, anc):
                return True
        return False

    classes = {}
    for _ in range(int(input())):
        name, *ancs = input().split(" : ")
        classes[name] = [anc for anc in ancs[0].split()] if ancs else []

    for _ in range(int(input())):
        a, d = input().split()
        print("Yes" if is_anc(d, a) else "No")


def m_1_6_2():
    """
    Реализуйте структуру данных, представляющую собой расширенную
    структуру стек. Необходимо поддерживать добавление элемента на
    вершину стека, удаление с вершины стека, и необходимо поддерживать
    операции сложения, вычитания, умножения и целочисленного деления.
    Операция сложения на стеке определяется следующим образом.
    Со стека снимается верхний элемент (top1), затем снимается следующий
    верхний элемент (top2), и затем как результат операции сложения на
    вершину стека кладется элемент, равный top1 + top2.
    Аналогичным образом определяются операции вычитания (top1 - top2),
    умножения (top1 * top2) и целочисленного деления (top1 // top2).
    Реализуйте эту структуру данных как класс ExtendedStack, отнаследовав
    его от стандартного класса list.
    Примечание Для добавления элемента на стек используется метод append,
    а для снятия со стека – метод pop. Гарантируется, что операции будут
    совершаться только когда в стеке есть хотя бы два элемента.
    """

    class ExtendedStack(list):
        def sum(self):
            top1 = self.pop()
            top2 = self.pop()
            self.append(top1 + top2)

        def sub(self):
            top1 = self.pop()
            top2 = self.pop()
            self.append(top1 - top2)

        def mul(self):
            top1 = self.pop()
            top2 = self.pop()
            self.append(top1 * top2)

        def div(self):
            top1 = self.pop()
            top2 = self.pop()
            self.append(top1 // top2)


def m_1_6_3():
    """
    Одно из применений множественного наследование – расширение
    функциональности класса каким-то заранее определенным способом.
    Например, если нам понадобится логировать какую-то информацию
    при обращении к методам класса. Рассмотрим класс Loggable.
    У него есть ровно один метод log, который позволяет выводить в лог
    (в данном случае в stdout) какое-то сообщение, добавляя при этом
    текущее время. Реализуйте класс LoggableList, отнаследовав его от
    классов list и Loggable таким образом, чтобы при добавлении элемента
    в список посредством метода append в лог отправлялось сообщение,
    состоящее из только что добавленного элемента.
    Примечание Ваша программа не должна содержать класс Loggable.
    При проверке вашей программе будет доступен этот класс, и он будет
    содержать метод log, описанный выше.
    """

    # import time
    class LoggableList(list, Loggable):
        def append(self, object):
            super().append(object)
            self.log(object)
